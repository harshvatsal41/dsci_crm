{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/Helper/jwtValidator.js"],"sourcesContent":["export const isTokenExpired = (token) => {\n    if (!token || typeof token !== 'string') return true;\n\n    try {\n        const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());\n        const expiryTime = decoded.exp * 1000; // Convert to milliseconds\n        return expiryTime < Date.now();\n    } catch (error) {\n        console.error('Error decoding token:', error);\n        return true;\n    }\n};\n\n\nexport const verifyToken = (token) => {\n    if (!token || typeof token !== 'string') {\n        console.error('Invalid token provided:', token);\n        return null; \n    }\n    try {\n\n        const tokenParts = token.split('.');\n        if (tokenParts.length !== 3) {\n            console.error('Invalid token format:', token);\n            return null;\n        }\n        const decoded = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString());\n        return decoded;\n    } catch (error) {\n        console.error('Error decoding token:', error);\n        return null; \n    }\n}\n\n//\n// export const isTokenExpired = (token) => {\n//     // Check if token is valid\n//     if (!token || typeof token !== 'string') {\n//         console.error('Invalid token provided:', token);\n//         return true; // Or handle the case as you see fit (e.g., return false or throw error)\n//     }\n//\n//     try {\n//         // Ensure the token contains three parts (header, payload, signature)\n//         const tokenParts = token.split('.');\n//         if (tokenParts.length !== 3) {\n//             console.error('Invalid token format:', token);\n//             return true;\n//         }\n//\n//         // Decode the payload (second part) of the JWT\n//         const decoded = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString());\n//\n//         // Check if the decoded token has an expiry time\n//         const expiryTime = decoded.exp * 1000; // Convert expiry time to milliseconds\n//         return expiryTime < Date.now();\n//     } catch (error) {\n//         console.error('Error decoding token:', error);\n//         return true; // Return true if an error occurs while decoding\n//     }\n// };\n"],"names":[],"mappings":";;;;AAImC;AAJ5B,MAAM,iBAAiB,CAAC;IAC3B,IAAI,CAAC,SAAS,OAAO,UAAU,UAAU,OAAO;IAEhD,IAAI;QACA,MAAM,UAAU,KAAK,KAAK,CAAC,qHAAA,CAAA,SAAM,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,UAAU,QAAQ;QAC9E,MAAM,aAAa,QAAQ,GAAG,GAAG,MAAM,0BAA0B;QACjE,OAAO,aAAa,KAAK,GAAG;IAChC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO;IACX;AACJ;AAGO,MAAM,cAAc,CAAC;IACxB,IAAI,CAAC,SAAS,OAAO,UAAU,UAAU;QACrC,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO;IACX;IACA,IAAI;QAEA,MAAM,aAAa,MAAM,KAAK,CAAC;QAC/B,IAAI,WAAW,MAAM,KAAK,GAAG;YACzB,QAAQ,KAAK,CAAC,yBAAyB;YACvC,OAAO;QACX;QACA,MAAM,UAAU,KAAK,KAAK,CAAC,qHAAA,CAAA,SAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE,UAAU,QAAQ;QACxE,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO;IACX;AACJ,EAEA,EAAE;CACF,6CAA6C;CAC7C,iCAAiC;CACjC,iDAAiD;CACjD,2DAA2D;CAC3D,gGAAgG;CAChG,QAAQ;CACR,EAAE;CACF,YAAY;CACZ,gFAAgF;CAChF,+CAA+C;CAC/C,yCAAyC;CACzC,6DAA6D;CAC7D,2BAA2B;CAC3B,YAAY;CACZ,EAAE;CACF,yDAAyD;CACzD,uFAAuF;CACvF,EAAE;CACF,2DAA2D;CAC3D,wFAAwF;CACxF,0CAA0C;CAC1C,wBAAwB;CACxB,yDAAyD;CACzD,wEAAwE;CACxE,QAAQ;CACR,KAAK"}},
    {"offset": {"line": 90, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.js"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport { isTokenExpired } from '@/Helper/jwtValidator';\r\n\r\nexport function middleware(request) {\r\n    console.log(\"Middleware triggered\");\r\n\r\n    const token = request.headers.get(\"Authorization\")?.split(\" \")[1];\r\n\r\n    const path = request.nextUrl.pathname;\r\n    const isApiRoute = path.startsWith(\"/api\");\r\n\r\n    if (!token || isTokenExpired(token)) {\r\n        if (isApiRoute) {\r\n            return NextResponse.json(\r\n                {\r\n                    message: \"Token not found or expired\",\r\n                    statusCode: 401,\r\n                    status: \"failed\",\r\n                },\r\n                { status: 401 }\r\n            );\r\n        }\r\n        else {\r\n            return NextResponse.redirect(new URL('/logout', request.url));\r\n        }\r\n    }\r\n\r\n    const protectedRoutes = ['/administration/profile', '/administration/dashboard'];\r\n\r\n\r\n    if (protectedRoutes.some(route => request.nextUrl.pathname.startsWith(route))) {\r\n        if (!token || isTokenExpired(token.value)) {\r\n            console.log(\"redirecting back\")\r\n            return NextResponse.redirect(new URL('/logout', request.url));\r\n        }\r\n    }\r\n\r\n    return NextResponse.next();\r\n}\r\n\r\n\r\nexport const config = {\r\n    matcher: ['/administration/dashboard:path*'],\r\n};\r\n\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,SAAS,WAAW,OAAO;IAC9B,QAAQ,GAAG,CAAC;IAEZ,MAAM,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,kBAAkB,MAAM,IAAI,CAAC,EAAE;IAEjE,MAAM,OAAO,QAAQ,OAAO,CAAC,QAAQ;IACrC,MAAM,aAAa,KAAK,UAAU,CAAC;IAEnC,IAAI,CAAC,SAAS,CAAA,GAAA,qIAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ;QACjC,IAAI,YAAY;YACZ,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBACI,SAAS;gBACT,YAAY;gBACZ,QAAQ;YACZ,GACA;gBAAE,QAAQ;YAAI;QAEtB,OACK;YACD,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,WAAW,QAAQ,GAAG;QAC/D;IACJ;IAEA,MAAM,kBAAkB;QAAC;QAA2B;KAA4B;IAGhF,IAAI,gBAAgB,IAAI,CAAC,CAAA,QAAS,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,SAAS;QAC3E,IAAI,CAAC,SAAS,CAAA,GAAA,qIAAA,CAAA,iBAAc,AAAD,EAAE,MAAM,KAAK,GAAG;YACvC,QAAQ,GAAG,CAAC;YACZ,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,WAAW,QAAQ,GAAG;QAC/D;IACJ;IAEA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC5B;AAGO,MAAM,SAAS;IAClB,SAAS;QAAC;KAAkC;AAChD"}}]
}